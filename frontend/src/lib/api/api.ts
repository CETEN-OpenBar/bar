/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI - Bar
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.11
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface Account {
    'id': string;
    'first_name': string;
    'last_name': string;
    'nickname'?: string;
    'google_id'?: string;
    'google_picture'?: string;
    'email_address': string;
    'balance': number;
    'points': number;
    'card_id'?: string;
    'card_pin': string;
    'password'?: string;
    'role': AccountRole;
    'price_role': AccountPriceRole;
    'restrictions': Array<AccountRestrictions>;
    'state': AccountState;
    'deleted_at'?: number;
    'deleted_by'?: string;
    'wants_to_staff': boolean;
}


/**
 * Role of the account
 */

export const AccountPriceRole = {
    AccountPriceCoutant: 'coutant',
    AccountPriceStaffBar: 'staff_bar',
    AccountPricePrivilegies: 'privilegies',
    AccountPriceMenu: 'menu',
    AccountPriceCeten: 'ceten',
    AccountPriceExterne: 'externe'
} as const;

export type AccountPriceRole = typeof AccountPriceRole[keyof typeof AccountPriceRole];


/**
 * Restrictions of the account
 */

export const AccountRestrictions = {
    AccountRemoteRestricted: 'remote_restricted',
    AccountBlocked: 'blocked'
} as const;

export type AccountRestrictions = typeof AccountRestrictions[keyof typeof AccountRestrictions];


/**
 * Role of the account
 */

export const AccountRole = {
    AccountStudent: 'student',
    AccountStudentWithBenefits: 'student_with_benefits',
    AccountMember: 'member',
    AccountAdmin: 'admin',
    AccountGhost: 'ghost',
    AccountSuperAdmin: 'superadmin'
} as const;

export type AccountRole = typeof AccountRole[keyof typeof AccountRole];


/**
 * State of the account
 */

export const AccountState = {
    AccountNotOnBoarded: 'not_onboarded',
    AccountOK: 'account_ok'
} as const;

export type AccountState = typeof AccountState[keyof typeof AccountState];


export interface CarouselImage {
    'id': string;
    /**
     * Image to display
     */
    'image_url': string;
    'deleted_at'?: number;
    'deleted_by'?: string;
}
export interface CarouselText {
    'id': string;
    /**
     * Text to display
     */
    'text': string;
    /**
     * Color of the text
     */
    'color': string;
    'deleted_at'?: number;
    'deleted_by'?: string;
}
export interface CarouselTextCreate {
    /**
     * Text to display
     */
    'text': string;
    /**
     * Color of the text
     */
    'color'?: string;
}
export interface CashMovement {
    'id': string;
    'amount': number;
    'old_amount': number;
    'reason': string;
    'created_at': number;
    'created_by': string;
    'created_by_name': string;
    'deleted_at'?: number;
    'deleted_by'?: string;
    'deleted_by_name'?: string;
}
export interface Category {
    'id': string;
    /**
     * Name of the current category
     */
    'name': string;
    /**
     * Link to picture of the current category
     */
    'picture_uri': string;
    'position': number;
    'hidden': boolean;
    'special_price': boolean;
    'deleted_at'?: number;
    'deleted_by'?: string;
}
export interface ConnectCard200Response {
    'message'?: Messages;
    'account'?: Account;
}


export interface ConnectCardRequest {
    'card_id': string;
    'card_pin': string;
}
export interface ConnectPasswordRequest {
    'card_id': string;
    'password': string;
}
export interface CourseItem {
    'amountToBuy': number;
    'item': Item;
}

export const ErrorCodes = {
    ErrBadRequest: 'bad_request',
    ErrForbidden: 'forbidden',
    ErrAccountNotFound: 'account_not_found',
    ErrQRInvalid: 'qr_invalid',
    ErrInternalServerError: 'internal_server_error',
    ErrServiceUnavailable: 'service_unavailable',
    ErrNotAuthenticated: 'not_authenticated',
    ErrImageNotFound: 'image_not_found',
    ErrTextNotFound: 'text_not_found',
    ErrCategoryNotFound: 'category_not_found',
    ErrItemNotFound: 'item_not_found',
    ErrRefillNotFound: 'refill_not_found',
    ErrStarringNotFound: 'starring_not_found',
    ErrTransactionNotFound: 'transaction_not_found'
} as const;

export type ErrorCodes = typeof ErrorCodes[keyof typeof ErrorCodes];



export const Fournisseur = {
    Auchan: 'auchan',
    Auchan_Drive: 'auchan_drive',
    Viennoiserie: 'viennoiserie',
    Promocash: 'promocash',
    Holy: 'holy'
} as const;

export type Fournisseur = typeof Fournisseur[keyof typeof Fournisseur];


export interface GetAccountAdmin200Response {
    'message'?: Messages;
    'is_allowed': boolean;
    'can_restore': boolean;
}


export interface GetAccountQRRequest {
    'card_pin': string;
}
export interface GetAccounts200Response {
    'message'?: Messages;
    'accounts': Array<Account>;
    'page': number;
    'limit': number;
    'max_page': number;
}


export interface GetAllItems200Response {
    'items': Array<Item>;
    'page': number;
    'limit': number;
    'max_page': number;
}
export interface GetCashMovements200Response {
    'cash_movements': Array<CashMovement>;
    'page': number;
    'limit': number;
    'max_page': number;
}
export interface GetCourse200Response {
    'items': Array<CourseItem>;
}
export interface GetDeletedAccounts200Response {
    'accounts': Array<Account>;
    'page': number;
    'limit': number;
    'max_page': number;
}
export interface GetDeletedCarouselImages200Response {
    'items': Array<CarouselImage>;
    'page': number;
    'limit': number;
    'max_page': number;
}
export interface GetDeletedCarouselTexts200Response {
    'items': Array<CarouselText>;
    'page': number;
    'limit': number;
    'max_page': number;
}
export interface GetDeletedCategories200Response {
    'categories': Array<Category>;
    'page': number;
    'limit': number;
    'max_page': number;
}
export interface GetDeletedStarring200Response {
    'starring': Array<Starring>;
    'page': number;
    'limit': number;
    'max_page': number;
}
export interface GetPendingRemoteRefills200Response {
    'remote_refills': Array<RemoteRefill>;
}
export interface GetRefills200Response {
    'refills': Array<Refill>;
    'page': number;
    'limit': number;
    'max_page': number;
}
export interface GetRemoteRefills200Response {
    'remote_refills': Array<RemoteRefill>;
    'page': number;
    'limit': number;
    'max_page': number;
}
export interface GetRestocks200Response {
    'restocks': Array<Restock>;
    'page': number;
    'limit': number;
    'max_page': number;
}
export interface GetStarrings200Response {
    'stars': Array<Starring>;
    'page': number;
    'limit': number;
    'max_page': number;
}
export interface GetTransactions200Response {
    'transactions': Array<Transaction>;
    'page': number;
    'limit': number;
    'max_page': number;
}
export interface HTTPError {
    'message': Messages;
    'error_code': ErrorCodes;
}


export interface ImportAccounts200Response {
    'message'?: Messages;
    'not_accepted'?: Array<string>;
}


export interface Item {
    'id': string;
    'prices': ItemPrices;
    'display_prices'?: ItemPrices;
    'display_price'?: number;
    'promotion'?: number;
    'promotion_ends_at'?: number;
    'amount_left': number;
    'optimal_amount': number;
    'buy_limit'?: number;
    'category_id': string;
    /**
     * Name of the current item
     */
    'name': string;
    /**
     * Link to picture of the current item
     */
    'picture_uri': string;
    'available_from'?: number;
    'available_until'?: number;
    'is_menu': boolean;
    'menu_items'?: Array<MenuItem>;
    'menu_categories'?: Array<MenuCategory>;
    'state': ItemState;
    'last_tva'?: number;
    'deleted_at'?: number;
    'deleted_by'?: string;
    'amount_per_bundle'?: number;
    /**
     * Referal code of the product in the Drive
     */
    'ref_bundle'?: string;
    'fournisseur'?: Fournisseur;
}


export interface ItemPrices {
    'coutant': number;
    'staff_bar': number;
    'privilegies': number;
    'menu': number;
    'ceten': number;
    'externe': number;
}
/**
 * State of the item
 */

export const ItemState = {
    ItemBuyable: 'buyable',
    ItemNotBuyable: 'not_buyable'
} as const;

export type ItemState = typeof ItemState[keyof typeof ItemState];


export interface MenuCategory {
    'id': string;
    /**
     * Name of the category
     */
    'name': string;
    /**
     * Link to picture of the category
     */
    'picture_uri': string;
    'amount': number;
}
export interface MenuItem {
    'id': string;
    /**
     * Name of the current item
     */
    'name': string;
    /**
     * Link to picture of the current item
     */
    'picture_uri': string;
    'promotion'?: number;
    'amount': number;
}

export const Messages = {
    MsgBadRequest: 'Bad request',
    MsgNotConnected: 'Not connected',
    MsgMissingFields: 'Missing fields %v',
    MsgAccountAlreadyExists: 'Account already exists',
    MsgAccountNotFound: 'Account not found',
    MsgAccountNotAllowed: 'Account is not allowed to use ressource',
    MsgAccountNotAvailable: 'Account cannot use ressource at the time being',
    MsgQRInvalid: 'Invalid QR Code nonce',
    MsgInternalServerError: 'Internal server error',
    MsgServiceUnavailable: 'Service Unavailable',
    MsgNotAuthenticated: 'You are not authenticated',
    MsgImageNotFound: 'Image does not exists',
    MsgTextNotFound: 'Text does not exists',
    MsgCategoryNotFound: 'Category does not exists',
    MsgItemNotFound: 'Item does not exists',
    MsgRefillNotFound: 'Refill does not exists',
    MsgStarringNotFound: 'Starring does not exists',
    MsgTransactionNotFound: 'Transaction does not exists'
} as const;

export type Messages = typeof Messages[keyof typeof Messages];


export interface NewAccount {
    'first_name': string;
    'last_name': string;
    'email_address': string;
    'card_id'?: string;
    'balance': number;
    'role': AccountRole;
    'price_role'?: AccountPriceRole;
}


export interface NewCashMovement {
    'amount': number;
    'reason': string;
}
export interface NewCategory {
    /**
     * Name of the current category
     */
    'name': string;
    'picture': string;
    'position': number;
}
export interface NewItem {
    'prices': ItemPrices;
    'promotion'?: number;
    'promotion_ends_at'?: number;
    'amount_left': number;
    'optimal_amount': number;
    'buy_limit'?: number;
    'available_from'?: number;
    'available_until'?: number;
    'is_menu'?: boolean;
    'menu_items'?: Array<MenuItem>;
    'menu_categories'?: Array<MenuCategory>;
    /**
     * Name of the current item
     */
    'name': string;
    /**
     * Picture of the current item
     */
    'picture': string;
    'state': ItemState;
}


export interface NewRestock {
    'items': Array<NewRestockItem>;
    'total_cost_ht': number;
    'total_cost_ttc': number;
    'driver_id'?: string;
    'type': RestockType;
    'state': RestockState;
}


export interface NewRestockItem {
    'item_id': string;
    /**
     * Name of the current item
     */
    'item_name': string;
    'amount_of_bundle': number;
    'amount_per_bundle': number;
    'bundle_cost_ht': number;
    'bundle_cost_ttc': number;
    'bundle_cost_float_ttc'?: number;
    'tva': number;
}
export interface NewTransaction {
    'items': Array<NewTransactionItem>;
    /**
     * Pin of the card
     */
    'card_pin': string;
    /**
     * True if the transaction was not created from a kiosk
     */
    'is_remote'?: boolean;
}
export interface NewTransactionItem {
    'item_id': string;
    'amount': number;
    'picked_categories_items'?: Array<NewTransactionItem>;
}
export interface PatchAccountPasswordRequest {
    'old_password': string;
    'new_password': string;
}
export interface PatchAccountPinRequest {
    'card_id'?: string;
    'old_card_pin': string;
    'new_card_pin': string;
}
export interface PostBorneAuthQRRequest {
    'nonce': string;
}
export interface Refill {
    'id': string;
    'account_id': string;
    /**
     * Name of the account
     */
    'account_name': string;
    'amount': number;
    'state': RefillState;
    'issued_at': number;
    'issued_by': string;
    'issued_by_name': string;
    'canceled_by'?: string;
    'canceled_by_name'?: string;
    'type': RefillType;
    'deleted_at'?: number;
    'deleted_by'?: string;
}



export const RefillState = {
    Valid: 'valid',
    Canceled: 'canceled'
} as const;

export type RefillState = typeof RefillState[keyof typeof RefillState];



export const RefillType = {
    RefillCash: 'cash',
    RefillCard: 'card',
    RefillTransfer: 'tranfer',
    RefillCheck: 'check',
    RefillHelloAsso: 'helloasso',
    RefillOther: 'other'
} as const;

export type RefillType = typeof RefillType[keyof typeof RefillType];


/**
 * A remote (HelloAsso) refill
 */
export interface RemoteRefill {
    'id': string;
    'state': RemoteRefillState;
    /**
     * HelloAsso checkout id
     */
    'checkout_intent_id'?: number;
    /**
     * HelloAsso order id, if the transaction suceeded
     */
    'order_id'?: number;
    'account_id': string;
    /**
     * Name of the account
     */
    'account_name': string;
    'amount': number;
    'created_at': number;
    'refill_id'?: string;
}



export const RemoteRefillState = {
    RemoteRefillStarted: 'started',
    RemoteRefillProcessed: 'processed',
    RemoteRefillAbandoned: 'abandoned'
} as const;

export type RemoteRefillState = typeof RemoteRefillState[keyof typeof RemoteRefillState];


export interface Restock {
    'items': Array<RestockItem>;
    'total_cost_ht': number;
    'total_cost_ttc': number;
    'driver_id'?: string;
    /**
     * Name of the driver
     */
    'driver_name'?: string;
    'id': string;
    'type': RestockType;
    'created_at': number;
    'created_by': string;
    'created_by_name': string;
    'deleted_at'?: number;
    'deleted_by'?: string;
    'state': RestockState;
}


export interface RestockItem {
    'item_id': string;
    /**
     * Name of the current item
     */
    'item_name': string;
    /**
     * Link to picture of the current item
     */
    'item_picture_uri': string;
    'amount_of_bundle': number;
    'amount_per_bundle': number;
    'bundle_cost_ht': number;
    'bundle_cost_ttc': number;
    'tva': number;
}

export const RestockState = {
    RestockFinished: 'finished',
    RestockPending: 'pending'
} as const;

export type RestockState = typeof RestockState[keyof typeof RestockState];



export const RestockType = {
    RestockAuchan: 'auchan',
    RestockAuchanDrive: 'auchan_drive',
    RestockViennoiserie: 'viennoiserie',
    RestockPromocash: 'promocash',
    RestockHoly: 'holy'
} as const;

export type RestockType = typeof RestockType[keyof typeof RestockType];


export interface Starring {
    'id': string;
    'account_id': string;
    /**
     * Name of the account
     */
    'account_name': string;
    'amount': number;
    'state': StarringState;
    'issued_at': number;
    'issued_by': string;
    'issued_by_name': string;
    'canceled_by'?: string;
    'canceled_by_name'?: string;
    'deleted_at'?: number;
    'deleted_by'?: string;
}



export const StarringState = {
    Valid: 'valid',
    Canceled: 'canceled'
} as const;

export type StarringState = typeof StarringState[keyof typeof StarringState];


export interface StartRemoteRefill200Response {
    'redirect_url': string;
}
export interface ToggleAccountWantsToStaff200Response {
    'message'?: Messages;
    'wants_to_staff': boolean;
}


export interface Transaction {
    'id': string;
    'items': Array<TransactionItem>;
    'account_id': string;
    /**
     * Name of the account
     */
    'account_name': string;
    /**
     * Nickname of the account
     */
    'account_nick_name'?: string;
    'total_cost': number;
    'state': TransactionState;
    'deleted_at'?: number;
    'deleted_by'?: string;
    'created_at': number;
    /**
     * True if the transaction was not created from a kiosk
     */
    'is_remote'?: boolean;
}


export interface TransactionItem {
    'item_id': string;
    /**
     * Link to picture of the current item
     */
    'picture_uri': string;
    /**
     * Name of the current item
     */
    'item_name': string;
    'item_amount': number;
    'item_already_done': number;
    'unit_cost': number;
    'is_menu': boolean;
    'menu_items'?: Array<MenuItem>;
    'menu_categories'?: Array<MenuCategory>;
    'picked_categories_items'?: Array<TransactionItem>;
    'total_cost': number;
    'state': TransactionItemState;
}



export const TransactionItemState = {
    TransactionItemStarted: 'started',
    TransactionItemTakenCareOf: 'taken_care_of',
    TransactionItemFinished: 'finished',
    TransactionItemCanceled: 'canceled'
} as const;

export type TransactionItemState = typeof TransactionItemState[keyof typeof TransactionItemState];



export const TransactionState = {
    TransactionStarted: 'started',
    TransactionTakenCareOf: 'taken_care_of',
    TransactionFinished: 'finished',
    TransactionCanceled: 'canceled'
} as const;

export type TransactionState = typeof TransactionState[keyof typeof TransactionState];


export interface UpdateAccountAdmin {
    'first_name'?: string;
    'last_name'?: string;
    'nickname'?: string;
    'email_address'?: string;
    'card_id'?: string;
    'role'?: AccountRole;
    'price_role'?: AccountPriceRole;
    'restrictions'?: Array<AccountRestrictions>;
    'state'?: AccountState;
}


export interface UpdateCategory {
    /**
     * Name of the current category
     */
    'name'?: string;
    'picture'?: string;
    'position'?: number;
    'hidden'?: boolean;
    'special_price'?: boolean;
}
export interface UpdateItem {
    'prices'?: ItemPrices;
    'amount_left'?: number;
    'buy_limit'?: number;
    'optimal_amount'?: number;
    'category_id'?: string;
    /**
     * Name of the current item
     */
    'name'?: string;
    /**
     * Picture of the current item
     */
    'picture'?: string;
    'promotion'?: number;
    'promotion_ends_at'?: number;
    'state'?: ItemState;
    'available_from'?: number;
    'available_until'?: number;
    'is_menu'?: boolean;
    'menu_items'?: Array<MenuItem>;
    'menu_categories'?: Array<MenuCategory>;
    'amount_per_bundle'?: number;
    'ref_bundle'?: string;
    'fournisseur'?: Fournisseur;
}



/**
 * AccountsApi - axios parameter creator
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Toggles the wants_to_staff flag
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminToggleAccountWantsToStaff: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('adminToggleAccountWantsToStaff', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/toggles/wants_to_staff`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the basic current account\'s information
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the current account can access the admin panel
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAdmin: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the account\'s information
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountId: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountId', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all accounts informations
         * @summary 
         * @param {number} [page] page to get
         * @param {number} [limit] number of accounts to get
         * @param {string} [search] search string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (page?: number, limit?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import accounts from a CSV file
         * @summary 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importAccounts: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/import/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication admin_auth required


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete account
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteAccountId: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('markDeleteAccountId', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update account
         * @summary 
         * @param {string} accountId ID of the account
         * @param {UpdateAccountAdmin} [updateAccountAdmin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountId: async (accountId: string, updateAccountAdmin?: UpdateAccountAdmin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('patchAccountId', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountAdmin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update account\'s password
         * @param {PatchAccountPasswordRequest} [patchAccountPasswordRequest] Passwords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountPassword: async (patchAccountPasswordRequest?: PatchAccountPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchAccountPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update\'s account card pin / id
         * @param {PatchAccountPinRequest} [patchAccountPinRequest] Card pin / id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountPin: async (patchAccountPinRequest?: PatchAccountPinRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchAccountPinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an account to the database
         * @summary 
         * @param {NewAccount} [newAccount] Add an account to the database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccounts: async (newAccount?: NewAccount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset the account\'s pin
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetAccountPin: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('resetAccountPin', 'accountId', accountId)
            const localVarPath = `/account/{account_id}/reset_pin`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Toggles the wants_to_staff flag
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleAccountWantsToStaff: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/toggles/wants_to_staff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Listen for changes on account
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watchAccount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/watch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Toggles the wants_to_staff flag
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminToggleAccountWantsToStaff(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToggleAccountWantsToStaff200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminToggleAccountWantsToStaff(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.adminToggleAccountWantsToStaff']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the basic current account\'s information
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectCard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check if the current account can access the admin panel
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountAdmin(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountAdmin(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccountAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the account\'s information
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountId(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountId(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccountId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all accounts informations
         * @summary 
         * @param {number} [page] page to get
         * @param {number} [limit] number of accounts to get
         * @param {string} [search] search string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(page?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(page, limit, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import accounts from a CSV file
         * @summary 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importAccounts(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportAccounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importAccounts(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.importAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete account
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteAccountId(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteAccountId(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.markDeleteAccountId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update account
         * @summary 
         * @param {string} accountId ID of the account
         * @param {UpdateAccountAdmin} [updateAccountAdmin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccountId(accountId: string, updateAccountAdmin?: UpdateAccountAdmin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAccountId(accountId, updateAccountAdmin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.patchAccountId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update account\'s password
         * @param {PatchAccountPasswordRequest} [patchAccountPasswordRequest] Passwords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccountPassword(patchAccountPasswordRequest?: PatchAccountPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectCard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAccountPassword(patchAccountPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.patchAccountPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update\'s account card pin / id
         * @param {PatchAccountPinRequest} [patchAccountPinRequest] Card pin / id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccountPin(patchAccountPinRequest?: PatchAccountPinRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectCard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAccountPin(patchAccountPinRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.patchAccountPin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add an account to the database
         * @summary 
         * @param {NewAccount} [newAccount] Add an account to the database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAccounts(newAccount?: NewAccount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAccounts(newAccount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.postAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset the account\'s pin
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetAccountPin(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetAccountPin(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.resetAccountPin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Toggles the wants_to_staff flag
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toggleAccountWantsToStaff(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToggleAccountWantsToStaff200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toggleAccountWantsToStaff(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.toggleAccountWantsToStaff']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Listen for changes on account
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async watchAccount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectCard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.watchAccount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.watchAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Toggles the wants_to_staff flag
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminToggleAccountWantsToStaff(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<ToggleAccountWantsToStaff200Response> {
            return localVarFp.adminToggleAccountWantsToStaff(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the basic current account\'s information
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(options?: RawAxiosRequestConfig): AxiosPromise<ConnectCard200Response> {
            return localVarFp.getAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * Check if the current account can access the admin panel
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAdmin(options?: RawAxiosRequestConfig): AxiosPromise<GetAccountAdmin200Response> {
            return localVarFp.getAccountAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the account\'s information
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountId(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.getAccountId(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all accounts informations
         * @summary 
         * @param {number} [page] page to get
         * @param {number} [limit] number of accounts to get
         * @param {string} [search] search string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(page?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAccounts200Response> {
            return localVarFp.getAccounts(page, limit, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Import accounts from a CSV file
         * @summary 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importAccounts(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<ImportAccounts200Response> {
            return localVarFp.importAccounts(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete account
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteAccountId(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.markDeleteAccountId(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update account
         * @summary 
         * @param {string} accountId ID of the account
         * @param {UpdateAccountAdmin} [updateAccountAdmin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountId(accountId: string, updateAccountAdmin?: UpdateAccountAdmin, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.patchAccountId(accountId, updateAccountAdmin, options).then((request) => request(axios, basePath));
        },
        /**
         * Update account\'s password
         * @param {PatchAccountPasswordRequest} [patchAccountPasswordRequest] Passwords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountPassword(patchAccountPasswordRequest?: PatchAccountPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConnectCard200Response> {
            return localVarFp.patchAccountPassword(patchAccountPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update\'s account card pin / id
         * @param {PatchAccountPinRequest} [patchAccountPinRequest] Card pin / id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountPin(patchAccountPinRequest?: PatchAccountPinRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConnectCard200Response> {
            return localVarFp.patchAccountPin(patchAccountPinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an account to the database
         * @summary 
         * @param {NewAccount} [newAccount] Add an account to the database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccounts(newAccount?: NewAccount, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.postAccounts(newAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset the account\'s pin
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetAccountPin(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetAccountPin(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Toggles the wants_to_staff flag
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleAccountWantsToStaff(options?: RawAxiosRequestConfig): AxiosPromise<ToggleAccountWantsToStaff200Response> {
            return localVarFp.toggleAccountWantsToStaff(options).then((request) => request(axios, basePath));
        },
        /**
         * Listen for changes on account
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watchAccount(options?: RawAxiosRequestConfig): AxiosPromise<ConnectCard200Response> {
            return localVarFp.watchAccount(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 */
export class AccountsApi extends BaseAPI {
    /**
     * Toggles the wants_to_staff flag
     * @summary 
     * @param {string} accountId ID of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminToggleAccountWantsToStaff(accountId: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).adminToggleAccountWantsToStaff(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the basic current account\'s information
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccount(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if the current account can access the admin panel
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountAdmin(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the account\'s information
     * @summary 
     * @param {string} accountId ID of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountId(accountId: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountId(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all accounts informations
     * @summary 
     * @param {number} [page] page to get
     * @param {number} [limit] number of accounts to get
     * @param {string} [search] search string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccounts(page?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccounts(page, limit, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import accounts from a CSV file
     * @summary 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public importAccounts(file?: File, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).importAccounts(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete account
     * @summary 
     * @param {string} accountId ID of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markDeleteAccountId(accountId: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).markDeleteAccountId(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update account
     * @summary 
     * @param {string} accountId ID of the account
     * @param {UpdateAccountAdmin} [updateAccountAdmin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchAccountId(accountId: string, updateAccountAdmin?: UpdateAccountAdmin, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).patchAccountId(accountId, updateAccountAdmin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update account\'s password
     * @param {PatchAccountPasswordRequest} [patchAccountPasswordRequest] Passwords
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchAccountPassword(patchAccountPasswordRequest?: PatchAccountPasswordRequest, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).patchAccountPassword(patchAccountPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update\'s account card pin / id
     * @param {PatchAccountPinRequest} [patchAccountPinRequest] Card pin / id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchAccountPin(patchAccountPinRequest?: PatchAccountPinRequest, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).patchAccountPin(patchAccountPinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an account to the database
     * @summary 
     * @param {NewAccount} [newAccount] Add an account to the database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postAccounts(newAccount?: NewAccount, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).postAccounts(newAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset the account\'s pin
     * @summary 
     * @param {string} accountId ID of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetAccountPin(accountId: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).resetAccountPin(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Toggles the wants_to_staff flag
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public toggleAccountWantsToStaff(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).toggleAccountWantsToStaff(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Listen for changes on account
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public watchAccount(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).watchAccount(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Callback for Google OAuth
         * @summary 
         * @param {string} code Google OAuth code
         * @param {string} state Google OAuth state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback: async (code: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('callback', 'code', code)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('callback', 'state', state)
            const localVarPath = `/auth/google/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Connect account to Google
         * @summary 
         * @param {string} qrNonce QR nonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectAccount: async (qrNonce: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qrNonce' is not null or undefined
            assertParamExists('connectAccount', 'qrNonce', qrNonce)
            const localVarPath = `/auth/google/begin/{qr_nonce}`
                .replace(`{${"qr_nonce"}}`, encodeURIComponent(String(qrNonce)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Connect account to card
         * @summary 
         * @param {ConnectCardRequest} [connectCardRequest] Card id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectCard: async (connectCardRequest?: ConnectCardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication local_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Local-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectCardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Connect account to Google
         * @summary 
         * @param {string} r Redirect to this url after connecting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectGoogle: async (r: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'r' is not null or undefined
            assertParamExists('connectGoogle', 'r', r)
            const localVarPath = `/auth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (r !== undefined) {
                localVarQueryParameter['r'] = r;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Connect account with password
         * @summary 
         * @param {ConnectPasswordRequest} [connectPasswordRequest] Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectPassword: async (connectPasswordRequest?: ConnectPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication local_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Local-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the QR code to connect account to Google
         * @summary 
         * @param {GetAccountQRRequest} [getAccountQRRequest] Card pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountQR: async (getAccountQRRequest?: GetAccountQRRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/qr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication not_onboarded required

            // authentication auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAccountQRRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication not_onboarded required

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Callback for Google OAuth
         * @summary 
         * @param {string} code Google OAuth code
         * @param {string} state Google OAuth state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callback(code: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callback(code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.callback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Connect account to Google
         * @summary 
         * @param {string} qrNonce QR nonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectAccount(qrNonce: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectAccount(qrNonce, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.connectAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Connect account to card
         * @summary 
         * @param {ConnectCardRequest} [connectCardRequest] Card id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectCard(connectCardRequest?: ConnectCardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectCard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectCard(connectCardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.connectCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Connect account to Google
         * @summary 
         * @param {string} r Redirect to this url after connecting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectGoogle(r: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectGoogle(r, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.connectGoogle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Connect account with password
         * @summary 
         * @param {ConnectPasswordRequest} [connectPasswordRequest] Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectPassword(connectPasswordRequest?: ConnectPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectCard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectPassword(connectPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.connectPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the QR code to connect account to Google
         * @summary 
         * @param {GetAccountQRRequest} [getAccountQRRequest] Card pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountQR(getAccountQRRequest?: GetAccountQRRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountQR(getAccountQRRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getAccountQR']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logout
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Callback for Google OAuth
         * @summary 
         * @param {string} code Google OAuth code
         * @param {string} state Google OAuth state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback(code: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.callback(code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Connect account to Google
         * @summary 
         * @param {string} qrNonce QR nonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectAccount(qrNonce: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.connectAccount(qrNonce, options).then((request) => request(axios, basePath));
        },
        /**
         * Connect account to card
         * @summary 
         * @param {ConnectCardRequest} [connectCardRequest] Card id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectCard(connectCardRequest?: ConnectCardRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConnectCard200Response> {
            return localVarFp.connectCard(connectCardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Connect account to Google
         * @summary 
         * @param {string} r Redirect to this url after connecting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectGoogle(r: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.connectGoogle(r, options).then((request) => request(axios, basePath));
        },
        /**
         * Connect account with password
         * @summary 
         * @param {ConnectPasswordRequest} [connectPasswordRequest] Password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectPassword(connectPasswordRequest?: ConnectPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConnectCard200Response> {
            return localVarFp.connectPassword(connectPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the QR code to connect account to Google
         * @summary 
         * @param {GetAccountQRRequest} [getAccountQRRequest] Card pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountQR(getAccountQRRequest?: GetAccountQRRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getAccountQR(getAccountQRRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * Callback for Google OAuth
     * @summary 
     * @param {string} code Google OAuth code
     * @param {string} state Google OAuth state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public callback(code: string, state: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).callback(code, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Connect account to Google
     * @summary 
     * @param {string} qrNonce QR nonce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectAccount(qrNonce: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).connectAccount(qrNonce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Connect account to card
     * @summary 
     * @param {ConnectCardRequest} [connectCardRequest] Card id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectCard(connectCardRequest?: ConnectCardRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).connectCard(connectCardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Connect account to Google
     * @summary 
     * @param {string} r Redirect to this url after connecting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectGoogle(r: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).connectGoogle(r, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Connect account with password
     * @summary 
     * @param {ConnectPasswordRequest} [connectPasswordRequest] Password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connectPassword(connectPasswordRequest?: ConnectPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).connectPassword(connectPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the QR code to connect account to Google
     * @summary 
     * @param {GetAccountQRRequest} [getAccountQRRequest] Card pin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountQR(getAccountQRRequest?: GetAccountQRRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getAccountQR(getAccountQRRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CarouselApi - axios parameter creator
 */
export const CarouselApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a carousel image
         * @param {File} image Image to display
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCarouselImage: async (image: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'image' is not null or undefined
            assertParamExists('addCarouselImage', 'image', image)
            const localVarPath = `/carousel/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication admin_auth required


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a carousel text
         * @param {CarouselTextCreate} carouselTextCreate Carousel text object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCarouselText: async (carouselTextCreate: CarouselTextCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carouselTextCreate' is not null or undefined
            assertParamExists('addCarouselText', 'carouselTextCreate', carouselTextCreate)
            const localVarPath = `/carousel/texts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(carouselTextCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a carousel image
         * @param {string} imageId ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarouselImage: async (imageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getCarouselImage', 'imageId', imageId)
            const localVarPath = `/carousel/images/{image_id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get carousel images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarouselImages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/carousel/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get carousel texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarouselTexts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/carousel/texts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a carousel image
         * @param {string} imageId ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteCarouselImage: async (imageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('markDeleteCarouselImage', 'imageId', imageId)
            const localVarPath = `/carousel/images/{image_id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a carousel text
         * @param {string} textId ID of the text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteCarouselText: async (textId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textId' is not null or undefined
            assertParamExists('markDeleteCarouselText', 'textId', textId)
            const localVarPath = `/carousel/texts/{text_id}`
                .replace(`{${"text_id"}}`, encodeURIComponent(String(textId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CarouselApi - functional programming interface
 */
export const CarouselApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CarouselApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a carousel image
         * @param {File} image Image to display
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCarouselImage(image: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarouselImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCarouselImage(image, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarouselApi.addCarouselImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a carousel text
         * @param {CarouselTextCreate} carouselTextCreate Carousel text object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCarouselText(carouselTextCreate: CarouselTextCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarouselText>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCarouselText(carouselTextCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarouselApi.addCarouselText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a carousel image
         * @param {string} imageId ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCarouselImage(imageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCarouselImage(imageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarouselApi.getCarouselImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get carousel images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCarouselImages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CarouselImage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCarouselImages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarouselApi.getCarouselImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get carousel texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCarouselTexts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CarouselText>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCarouselTexts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarouselApi.getCarouselTexts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a carousel image
         * @param {string} imageId ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteCarouselImage(imageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteCarouselImage(imageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarouselApi.markDeleteCarouselImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a carousel text
         * @param {string} textId ID of the text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteCarouselText(textId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteCarouselText(textId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CarouselApi.markDeleteCarouselText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CarouselApi - factory interface
 */
export const CarouselApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CarouselApiFp(configuration)
    return {
        /**
         * Add a carousel image
         * @param {File} image Image to display
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCarouselImage(image: File, options?: RawAxiosRequestConfig): AxiosPromise<CarouselImage> {
            return localVarFp.addCarouselImage(image, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a carousel text
         * @param {CarouselTextCreate} carouselTextCreate Carousel text object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCarouselText(carouselTextCreate: CarouselTextCreate, options?: RawAxiosRequestConfig): AxiosPromise<CarouselText> {
            return localVarFp.addCarouselText(carouselTextCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a carousel image
         * @param {string} imageId ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarouselImage(imageId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getCarouselImage(imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get carousel images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarouselImages(options?: RawAxiosRequestConfig): AxiosPromise<Array<CarouselImage>> {
            return localVarFp.getCarouselImages(options).then((request) => request(axios, basePath));
        },
        /**
         * Get carousel texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarouselTexts(options?: RawAxiosRequestConfig): AxiosPromise<Array<CarouselText>> {
            return localVarFp.getCarouselTexts(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a carousel image
         * @param {string} imageId ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteCarouselImage(imageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.markDeleteCarouselImage(imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a carousel text
         * @param {string} textId ID of the text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteCarouselText(textId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.markDeleteCarouselText(textId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CarouselApi - object-oriented interface
 */
export class CarouselApi extends BaseAPI {
    /**
     * Add a carousel image
     * @param {File} image Image to display
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addCarouselImage(image: File, options?: RawAxiosRequestConfig) {
        return CarouselApiFp(this.configuration).addCarouselImage(image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a carousel text
     * @param {CarouselTextCreate} carouselTextCreate Carousel text object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addCarouselText(carouselTextCreate: CarouselTextCreate, options?: RawAxiosRequestConfig) {
        return CarouselApiFp(this.configuration).addCarouselText(carouselTextCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a carousel image
     * @param {string} imageId ID of the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCarouselImage(imageId: string, options?: RawAxiosRequestConfig) {
        return CarouselApiFp(this.configuration).getCarouselImage(imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get carousel images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCarouselImages(options?: RawAxiosRequestConfig) {
        return CarouselApiFp(this.configuration).getCarouselImages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get carousel texts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCarouselTexts(options?: RawAxiosRequestConfig) {
        return CarouselApiFp(this.configuration).getCarouselTexts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a carousel image
     * @param {string} imageId ID of the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markDeleteCarouselImage(imageId: string, options?: RawAxiosRequestConfig) {
        return CarouselApiFp(this.configuration).markDeleteCarouselImage(imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a carousel text
     * @param {string} textId ID of the text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markDeleteCarouselText(textId: string, options?: RawAxiosRequestConfig) {
        return CarouselApiFp(this.configuration).markDeleteCarouselText(textId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CashMovementsApi - axios parameter creator
 */
export const CashMovementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a cash movement
         * @param {NewCashMovement} newCashMovement Cash movement to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCashMovement: async (newCashMovement: NewCashMovement, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newCashMovement' is not null or undefined
            assertParamExists('createCashMovement', 'newCashMovement', newCashMovement)
            const localVarPath = `/cash_movements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newCashMovement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a cash movement
         * @param {string} cashMovementId ID of the cash movement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCashMovement: async (cashMovementId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cashMovementId' is not null or undefined
            assertParamExists('deleteCashMovement', 'cashMovementId', cashMovementId)
            const localVarPath = `/cash_movements/{cash_movement_id}`
                .replace(`{${"cash_movement_id"}}`, encodeURIComponent(String(cashMovementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get cash movements
         * @param {number} [page] Page number
         * @param {number} [limit] Number of cash movements per page
         * @param {string} [search] search string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashMovements: async (page?: number, limit?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cash_movements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CashMovementsApi - functional programming interface
 */
export const CashMovementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CashMovementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a cash movement
         * @param {NewCashMovement} newCashMovement Cash movement to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCashMovement(newCashMovement: NewCashMovement, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashMovement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCashMovement(newCashMovement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashMovementsApi.createCashMovement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a cash movement
         * @param {string} cashMovementId ID of the cash movement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCashMovement(cashMovementId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCashMovement(cashMovementId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashMovementsApi.deleteCashMovement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get cash movements
         * @param {number} [page] Page number
         * @param {number} [limit] Number of cash movements per page
         * @param {string} [search] search string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCashMovements(page?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCashMovements200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCashMovements(page, limit, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CashMovementsApi.getCashMovements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CashMovementsApi - factory interface
 */
export const CashMovementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CashMovementsApiFp(configuration)
    return {
        /**
         * Create a cash movement
         * @param {NewCashMovement} newCashMovement Cash movement to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCashMovement(newCashMovement: NewCashMovement, options?: RawAxiosRequestConfig): AxiosPromise<CashMovement> {
            return localVarFp.createCashMovement(newCashMovement, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a cash movement
         * @param {string} cashMovementId ID of the cash movement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCashMovement(cashMovementId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCashMovement(cashMovementId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get cash movements
         * @param {number} [page] Page number
         * @param {number} [limit] Number of cash movements per page
         * @param {string} [search] search string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashMovements(page?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCashMovements200Response> {
            return localVarFp.getCashMovements(page, limit, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CashMovementsApi - object-oriented interface
 */
export class CashMovementsApi extends BaseAPI {
    /**
     * Create a cash movement
     * @param {NewCashMovement} newCashMovement Cash movement to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCashMovement(newCashMovement: NewCashMovement, options?: RawAxiosRequestConfig) {
        return CashMovementsApiFp(this.configuration).createCashMovement(newCashMovement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a cash movement
     * @param {string} cashMovementId ID of the cash movement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCashMovement(cashMovementId: string, options?: RawAxiosRequestConfig) {
        return CashMovementsApiFp(this.configuration).deleteCashMovement(cashMovementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get cash movements
     * @param {number} [page] Page number
     * @param {number} [limit] Number of cash movements per page
     * @param {string} [search] search string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCashMovements(page?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig) {
        return CashMovementsApiFp(this.configuration).getCashMovements(page, limit, search, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoriesApi - axios parameter creator
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all categories
         * @param {boolean} [hidden] Show hidden categories (admin only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (hidden?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required

            if (hidden !== undefined) {
                localVarQueryParameter['hidden'] = hidden;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategory', 'categoryId', categoryId)
            const localVarPath = `/categories/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a category picture
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryPicture: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategoryPicture', 'categoryId', categoryId)
            const localVarPath = `/categories/{category_id}/picture`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteCategory: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('markDeleteCategory', 'categoryId', categoryId)
            const localVarPath = `/categories/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a category
         * @param {string} categoryId ID of the category
         * @param {UpdateCategory} updateCategory Category object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCategory: async (categoryId: string, updateCategory: UpdateCategory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('patchCategory', 'categoryId', categoryId)
            // verify required parameter 'updateCategory' is not null or undefined
            assertParamExists('patchCategory', 'updateCategory', updateCategory)
            const localVarPath = `/categories/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new category
         * @param {NewCategory} newCategory Category object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategory: async (newCategory: NewCategory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newCategory' is not null or undefined
            assertParamExists('postCategory', 'newCategory', newCategory)
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all categories
         * @param {boolean} [hidden] Show hidden categories (admin only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(hidden?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(hidden, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.getCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategory(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.getCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a category picture
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryPicture(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryPicture(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.getCategoryPicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteCategory(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.markDeleteCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a category
         * @param {string} categoryId ID of the category
         * @param {UpdateCategory} updateCategory Category object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCategory(categoryId: string, updateCategory: UpdateCategory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCategory(categoryId, updateCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.patchCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new category
         * @param {NewCategory} newCategory Category object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCategory(newCategory: NewCategory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCategory(newCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.postCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoriesApi - factory interface
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Get all categories
         * @param {boolean} [hidden] Show hidden categories (admin only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(hidden?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Category>> {
            return localVarFp.getCategories(hidden, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(categoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<Category> {
            return localVarFp.getCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a category picture
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryPicture(categoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getCategoryPicture(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteCategory(categoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.markDeleteCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a category
         * @param {string} categoryId ID of the category
         * @param {UpdateCategory} updateCategory Category object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCategory(categoryId: string, updateCategory: UpdateCategory, options?: RawAxiosRequestConfig): AxiosPromise<Category> {
            return localVarFp.patchCategory(categoryId, updateCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new category
         * @param {NewCategory} newCategory Category object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategory(newCategory: NewCategory, options?: RawAxiosRequestConfig): AxiosPromise<Category> {
            return localVarFp.postCategory(newCategory, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Get all categories
     * @param {boolean} [hidden] Show hidden categories (admin only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCategories(hidden?: boolean, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getCategories(hidden, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a category
     * @param {string} categoryId ID of the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCategory(categoryId: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a category picture
     * @param {string} categoryId ID of the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCategoryPicture(categoryId: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getCategoryPicture(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a category
     * @param {string} categoryId ID of the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markDeleteCategory(categoryId: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).markDeleteCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a category
     * @param {string} categoryId ID of the category
     * @param {UpdateCategory} updateCategory Category object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchCategory(categoryId: string, updateCategory: UpdateCategory, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).patchCategory(categoryId, updateCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new category
     * @param {NewCategory} newCategory Category object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCategory(newCategory: NewCategory, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).postCategory(newCategory, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourseApi - axios parameter creator
 */
export const CourseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get generated course
         * @param {string} [fournisseur] Fournisseur name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse: async (fournisseur?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/course`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (fournisseur !== undefined) {
                localVarQueryParameter['fournisseur'] = fournisseur;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseApi - functional programming interface
 */
export const CourseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseApiAxiosParamCreator(configuration)
    return {
        /**
         * Get generated course
         * @param {string} [fournisseur] Fournisseur name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCourse(fournisseur?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCourse200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCourse(fournisseur, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseApi.getCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseApi - factory interface
 */
export const CourseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseApiFp(configuration)
    return {
        /**
         * Get generated course
         * @param {string} [fournisseur] Fournisseur name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCourse(fournisseur?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCourse200Response> {
            return localVarFp.getCourse(fournisseur, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseApi - object-oriented interface
 */
export class CourseApi extends BaseAPI {
    /**
     * Get generated course
     * @param {string} [fournisseur] Fournisseur name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCourse(fournisseur?: string, options?: RawAxiosRequestConfig) {
        return CourseApiFp(this.configuration).getCourse(fournisseur, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Websocket to listen for scan & callback (for cool animations)
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountQRWebsocket: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/qr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Websocket to listen for scan & callback (for cool animations)
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBorneAuthQRWebsocket: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/qr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication local_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Local-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the connection to connect
         * @summary 
         * @param {PostBorneAuthQRRequest} [postBorneAuthQRRequest] Nonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBorneAuthQR: async (postBorneAuthQRRequest?: PostBorneAuthQRRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/qr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postBorneAuthQRRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Websocket to listen for scan & callback (for cool animations)
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountQRWebsocket(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountQRWebsocket(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAccountQRWebsocket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Websocket to listen for scan & callback (for cool animations)
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBorneAuthQRWebsocket(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBorneAuthQRWebsocket(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBorneAuthQRWebsocket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate the connection to connect
         * @summary 
         * @param {PostBorneAuthQRRequest} [postBorneAuthQRRequest] Nonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBorneAuthQR(postBorneAuthQRRequest?: PostBorneAuthQRRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectCard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postBorneAuthQR(postBorneAuthQRRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postBorneAuthQR']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Websocket to listen for scan & callback (for cool animations)
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountQRWebsocket(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getAccountQRWebsocket(options).then((request) => request(axios, basePath));
        },
        /**
         * Websocket to listen for scan & callback (for cool animations)
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBorneAuthQRWebsocket(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getBorneAuthQRWebsocket(options).then((request) => request(axios, basePath));
        },
        /**
         * Validate the connection to connect
         * @summary 
         * @param {PostBorneAuthQRRequest} [postBorneAuthQRRequest] Nonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBorneAuthQR(postBorneAuthQRRequest?: PostBorneAuthQRRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConnectCard200Response> {
            return localVarFp.postBorneAuthQR(postBorneAuthQRRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * Websocket to listen for scan & callback (for cool animations)
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountQRWebsocket(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAccountQRWebsocket(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Websocket to listen for scan & callback (for cool animations)
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBorneAuthQRWebsocket(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBorneAuthQRWebsocket(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate the connection to connect
     * @summary 
     * @param {PostBorneAuthQRRequest} [postBorneAuthQRRequest] Nonce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postBorneAuthQR(postBorneAuthQRRequest?: PostBorneAuthQRRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postBorneAuthQR(postBorneAuthQRRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeletedApi - axios parameter creator
 */
export const DeletedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permanently deletes an account (SUPERADMIN)
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccount', 'accountId', accountId)
            const localVarPath = `/deleted/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a carousel image (SUPERADMIN)
         * @param {string} imageId ID of the carousel image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCarouselImage: async (imageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('deleteCarouselImage', 'imageId', imageId)
            const localVarPath = `/deleted/carousel/images/{image_id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a carousel text (SUPERADMIN)
         * @param {string} textId ID of the carousel text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCarouselText: async (textId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textId' is not null or undefined
            assertParamExists('deleteCarouselText', 'textId', textId)
            const localVarPath = `/deleted/carousel/texts/{text_id}`
                .replace(`{${"text_id"}}`, encodeURIComponent(String(textId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a category (SUPERADMIN)
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('deleteCategory', 'categoryId', categoryId)
            const localVarPath = `/deleted/categories/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes an item (SUPERADMIN)
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deleteItem', 'itemId', itemId)
            const localVarPath = `/deleted/items/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a refill (SUPERADMIN)
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRefill: async (refillId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refillId' is not null or undefined
            assertParamExists('deleteRefill', 'refillId', refillId)
            const localVarPath = `/deleted/refills/{refill_id}`
                .replace(`{${"refill_id"}}`, encodeURIComponent(String(refillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a starring (SUPERADMIN)
         * @param {string} starringId ID of the starring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStarring: async (starringId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'starringId' is not null or undefined
            assertParamExists('deleteStarring', 'starringId', starringId)
            const localVarPath = `/deleted/stars/{starring_id}`
                .replace(`{${"starring_id"}}`, encodeURIComponent(String(starringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a transaction (SUPERADMIN)
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('deleteTransaction', 'transactionId', transactionId)
            const localVarPath = `/deleted/transactions/{transaction_id}`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deleted accounts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {string} [search] search string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedAccounts: async (page?: number, limit?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleted/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deleted carousel images
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedCarouselImages: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleted/carousel/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deleted carousel texts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedCarouselTexts: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleted/carousel/texts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deleted categories
         * @param {number} [page] Page number
         * @param {number} [limit] Number of categories per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedCategories: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleted/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deleted items
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedItems: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleted/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deleted refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedRefills: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleted/refills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deleted starrings
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedStarring: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleted/stars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deleted transactions
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedTransactions: async (page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleted/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a deleted account
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedAccount: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('restoreDeletedAccount', 'accountId', accountId)
            const localVarPath = `/deleted/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a deleted carousel image
         * @param {string} imageId ID of the carousel image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedCarouselImage: async (imageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('restoreDeletedCarouselImage', 'imageId', imageId)
            const localVarPath = `/deleted/carousel/images/{image_id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a deleted carousel text
         * @param {string} textId ID of the carousel text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedCarouselText: async (textId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textId' is not null or undefined
            assertParamExists('restoreDeletedCarouselText', 'textId', textId)
            const localVarPath = `/deleted/carousel/texts/{text_id}`
                .replace(`{${"text_id"}}`, encodeURIComponent(String(textId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a deleted category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedCategory: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('restoreDeletedCategory', 'categoryId', categoryId)
            const localVarPath = `/deleted/categories/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a deleted item
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedItem: async (itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('restoreDeletedItem', 'itemId', itemId)
            const localVarPath = `/deleted/items/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a deleted refill
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedRefill: async (refillId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refillId' is not null or undefined
            assertParamExists('restoreDeletedRefill', 'refillId', refillId)
            const localVarPath = `/deleted/refills/{refill_id}`
                .replace(`{${"refill_id"}}`, encodeURIComponent(String(refillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a deleted starring
         * @param {string} starringId ID of the starring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedStarring: async (starringId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'starringId' is not null or undefined
            assertParamExists('restoreDeletedStarring', 'starringId', starringId)
            const localVarPath = `/deleted/stars/{starring_id}`
                .replace(`{${"starring_id"}}`, encodeURIComponent(String(starringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a deleted transaction
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedTransaction: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('restoreDeletedTransaction', 'transactionId', transactionId)
            const localVarPath = `/deleted/transactions/{transaction_id}`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeletedApi - functional programming interface
 */
export const DeletedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeletedApiAxiosParamCreator(configuration)
    return {
        /**
         * Permanently deletes an account (SUPERADMIN)
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.deleteAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a carousel image (SUPERADMIN)
         * @param {string} imageId ID of the carousel image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCarouselImage(imageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCarouselImage(imageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.deleteCarouselImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a carousel text (SUPERADMIN)
         * @param {string} textId ID of the carousel text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCarouselText(textId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCarouselText(textId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.deleteCarouselText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a category (SUPERADMIN)
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.deleteCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes an item (SUPERADMIN)
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItem(itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.deleteItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a refill (SUPERADMIN)
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRefill(refillId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRefill(refillId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.deleteRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a starring (SUPERADMIN)
         * @param {string} starringId ID of the starring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStarring(starringId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStarring(starringId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.deleteStarring']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a transaction (SUPERADMIN)
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransaction(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransaction(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.deleteTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get deleted accounts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {string} [search] search string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletedAccounts(page?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeletedAccounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletedAccounts(page, limit, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.getDeletedAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get deleted carousel images
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletedCarouselImages(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeletedCarouselImages200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletedCarouselImages(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.getDeletedCarouselImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get deleted carousel texts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletedCarouselTexts(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeletedCarouselTexts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletedCarouselTexts(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.getDeletedCarouselTexts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get deleted categories
         * @param {number} [page] Page number
         * @param {number} [limit] Number of categories per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletedCategories(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeletedCategories200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletedCategories(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.getDeletedCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get deleted items
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletedItems(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllItems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletedItems(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.getDeletedItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get deleted refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletedRefills(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRefills200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletedRefills(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.getDeletedRefills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get deleted starrings
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletedStarring(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeletedStarring200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletedStarring(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.getDeletedStarring']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get deleted transactions
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletedTransactions(page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletedTransactions(page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.getDeletedTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore a deleted account
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedAccount(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.restoreDeletedAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore a deleted carousel image
         * @param {string} imageId ID of the carousel image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedCarouselImage(imageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedCarouselImage(imageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.restoreDeletedCarouselImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore a deleted carousel text
         * @param {string} textId ID of the carousel text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedCarouselText(textId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedCarouselText(textId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.restoreDeletedCarouselText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore a deleted category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedCategory(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.restoreDeletedCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore a deleted item
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedItem(itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedItem(itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.restoreDeletedItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore a deleted refill
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedRefill(refillId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedRefill(refillId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.restoreDeletedRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore a deleted starring
         * @param {string} starringId ID of the starring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedStarring(starringId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedStarring(starringId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.restoreDeletedStarring']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore a deleted transaction
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedTransaction(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedTransaction(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeletedApi.restoreDeletedTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeletedApi - factory interface
 */
export const DeletedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeletedApiFp(configuration)
    return {
        /**
         * Permanently deletes an account (SUPERADMIN)
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a carousel image (SUPERADMIN)
         * @param {string} imageId ID of the carousel image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCarouselImage(imageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCarouselImage(imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a carousel text (SUPERADMIN)
         * @param {string} textId ID of the carousel text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCarouselText(textId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCarouselText(textId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a category (SUPERADMIN)
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(categoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes an item (SUPERADMIN)
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteItem(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a refill (SUPERADMIN)
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRefill(refillId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRefill(refillId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a starring (SUPERADMIN)
         * @param {string} starringId ID of the starring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStarring(starringId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteStarring(starringId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a transaction (SUPERADMIN)
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(transactionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTransaction(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deleted accounts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {string} [search] search string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedAccounts(page?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetDeletedAccounts200Response> {
            return localVarFp.getDeletedAccounts(page, limit, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deleted carousel images
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedCarouselImages(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetDeletedCarouselImages200Response> {
            return localVarFp.getDeletedCarouselImages(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deleted carousel texts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedCarouselTexts(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetDeletedCarouselTexts200Response> {
            return localVarFp.getDeletedCarouselTexts(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deleted categories
         * @param {number} [page] Page number
         * @param {number} [limit] Number of categories per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedCategories(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetDeletedCategories200Response> {
            return localVarFp.getDeletedCategories(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deleted items
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedItems(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetAllItems200Response> {
            return localVarFp.getDeletedItems(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deleted refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedRefills(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetRefills200Response> {
            return localVarFp.getDeletedRefills(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deleted starrings
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedStarring(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetDeletedStarring200Response> {
            return localVarFp.getDeletedStarring(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deleted transactions
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedTransactions(page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetTransactions200Response> {
            return localVarFp.getDeletedTransactions(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a deleted account
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedAccount(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restoreDeletedAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a deleted carousel image
         * @param {string} imageId ID of the carousel image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedCarouselImage(imageId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restoreDeletedCarouselImage(imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a deleted carousel text
         * @param {string} textId ID of the carousel text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedCarouselText(textId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restoreDeletedCarouselText(textId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a deleted category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedCategory(categoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restoreDeletedCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a deleted item
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedItem(itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restoreDeletedItem(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a deleted refill
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedRefill(refillId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restoreDeletedRefill(refillId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a deleted starring
         * @param {string} starringId ID of the starring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedStarring(starringId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restoreDeletedStarring(starringId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a deleted transaction
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedTransaction(transactionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restoreDeletedTransaction(transactionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeletedApi - object-oriented interface
 */
export class DeletedApi extends BaseAPI {
    /**
     * Permanently deletes an account (SUPERADMIN)
     * @param {string} accountId ID of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAccount(accountId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).deleteAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a carousel image (SUPERADMIN)
     * @param {string} imageId ID of the carousel image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCarouselImage(imageId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).deleteCarouselImage(imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a carousel text (SUPERADMIN)
     * @param {string} textId ID of the carousel text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCarouselText(textId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).deleteCarouselText(textId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a category (SUPERADMIN)
     * @param {string} categoryId ID of the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCategory(categoryId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).deleteCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes an item (SUPERADMIN)
     * @param {string} itemId ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteItem(itemId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).deleteItem(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a refill (SUPERADMIN)
     * @param {string} refillId ID of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRefill(refillId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).deleteRefill(refillId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a starring (SUPERADMIN)
     * @param {string} starringId ID of the starring
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteStarring(starringId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).deleteStarring(starringId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a transaction (SUPERADMIN)
     * @param {string} transactionId ID of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTransaction(transactionId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).deleteTransaction(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deleted accounts
     * @param {number} [page] Page number
     * @param {number} [limit] Number of accounts per page
     * @param {string} [search] search string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDeletedAccounts(page?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).getDeletedAccounts(page, limit, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deleted carousel images
     * @param {number} [page] Page number
     * @param {number} [limit] Number of accounts per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDeletedCarouselImages(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).getDeletedCarouselImages(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deleted carousel texts
     * @param {number} [page] Page number
     * @param {number} [limit] Number of accounts per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDeletedCarouselTexts(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).getDeletedCarouselTexts(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deleted categories
     * @param {number} [page] Page number
     * @param {number} [limit] Number of categories per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDeletedCategories(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).getDeletedCategories(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deleted items
     * @param {number} [page] Page number
     * @param {number} [limit] Number of accounts per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDeletedItems(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).getDeletedItems(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deleted refills
     * @param {number} [page] Page number
     * @param {number} [limit] Number of accounts per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDeletedRefills(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).getDeletedRefills(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deleted starrings
     * @param {number} [page] Page number
     * @param {number} [limit] Number of accounts per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDeletedStarring(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).getDeletedStarring(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deleted transactions
     * @param {number} [page] Page number
     * @param {number} [limit] Number of accounts per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDeletedTransactions(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).getDeletedTransactions(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a deleted account
     * @param {string} accountId ID of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public restoreDeletedAccount(accountId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).restoreDeletedAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a deleted carousel image
     * @param {string} imageId ID of the carousel image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public restoreDeletedCarouselImage(imageId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).restoreDeletedCarouselImage(imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a deleted carousel text
     * @param {string} textId ID of the carousel text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public restoreDeletedCarouselText(textId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).restoreDeletedCarouselText(textId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a deleted category
     * @param {string} categoryId ID of the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public restoreDeletedCategory(categoryId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).restoreDeletedCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a deleted item
     * @param {string} itemId ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public restoreDeletedItem(itemId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).restoreDeletedItem(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a deleted refill
     * @param {string} refillId ID of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public restoreDeletedRefill(refillId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).restoreDeletedRefill(refillId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a deleted starring
     * @param {string} starringId ID of the starring
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public restoreDeletedStarring(starringId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).restoreDeletedStarring(starringId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a deleted transaction
     * @param {string} transactionId ID of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public restoreDeletedTransaction(transactionId: string, options?: RawAxiosRequestConfig) {
        return DeletedApiFp(this.configuration).restoreDeletedTransaction(transactionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemsApi - axios parameter creator
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (admin) Get all incoherent items with filters and pagination
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {ItemState} [state] Filter by state
         * @param {string} [categoryId] Filter by category
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIncoherentItems: async (page?: number, limit?: number, state?: ItemState, categoryId?: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/incoherent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (admin) Get all items with filters and pagination
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {ItemState} [state] Filter by state
         * @param {string} [categoryId] Filter by category
         * @param {string} [name] Filter by name
         * @param {Fournisseur} [fournisseur] Filter by fournisseur
         * @param {string} [refBundle] Filter by reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItems: async (page?: number, limit?: number, state?: ItemState, categoryId?: string, name?: string, fournisseur?: Fournisseur, refBundle?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (fournisseur !== undefined) {
                localVarQueryParameter['fournisseur'] = fournisseur;
            }

            if (refBundle !== undefined) {
                localVarQueryParameter['ref_bundle'] = refBundle;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all items of a category
         * @param {string} categoryId ID of the category
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {ItemState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryItems: async (categoryId: string, page?: number, limit?: number, state?: ItemState, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategoryItems', 'categoryId', categoryId)
            const localVarPath = `/categories/{category_id}/items`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an item
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem: async (itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getItem', 'itemId', itemId)
            const localVarPath = `/item/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an item picture
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemPicture: async (categoryId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getItemPicture', 'categoryId', categoryId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getItemPicture', 'itemId', itemId)
            const localVarPath = `/categories/{category_id}/items/{item_id}/picture`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an item
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteItem: async (categoryId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('markDeleteItem', 'categoryId', categoryId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('markDeleteItem', 'itemId', itemId)
            const localVarPath = `/categories/{category_id}/items/{item_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an item
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {UpdateItem} updateItem Item object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItem: async (categoryId: string, itemId: string, updateItem: UpdateItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('patchItem', 'categoryId', categoryId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('patchItem', 'itemId', itemId)
            // verify required parameter 'updateItem' is not null or undefined
            assertParamExists('patchItem', 'updateItem', updateItem)
            const localVarPath = `/categories/{category_id}/items/{item_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new item
         * @param {string} categoryId ID of the category
         * @param {NewItem} newItem Item object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItem: async (categoryId: string, newItem: NewItem, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('postItem', 'categoryId', categoryId)
            // verify required parameter 'newItem' is not null or undefined
            assertParamExists('postItem', 'newItem', newItem)
            const localVarPath = `/categories/{category_id}/items`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * (admin) Get all incoherent items with filters and pagination
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {ItemState} [state] Filter by state
         * @param {string} [categoryId] Filter by category
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllIncoherentItems(page?: number, limit?: number, state?: ItemState, categoryId?: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllItems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllIncoherentItems(page, limit, state, categoryId, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getAllIncoherentItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * (admin) Get all items with filters and pagination
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {ItemState} [state] Filter by state
         * @param {string} [categoryId] Filter by category
         * @param {string} [name] Filter by name
         * @param {Fournisseur} [fournisseur] Filter by fournisseur
         * @param {string} [refBundle] Filter by reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllItems(page?: number, limit?: number, state?: ItemState, categoryId?: string, name?: string, fournisseur?: Fournisseur, refBundle?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllItems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllItems(page, limit, state, categoryId, name, fournisseur, refBundle, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getAllItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all items of a category
         * @param {string} categoryId ID of the category
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {ItemState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryItems(categoryId: string, page?: number, limit?: number, state?: ItemState, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllItems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryItems(categoryId, page, limit, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getCategoryItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an item
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItem(itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItem(itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an item picture
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemPicture(categoryId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemPicture(categoryId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getItemPicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an item
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteItem(categoryId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteItem(categoryId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.markDeleteItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an item
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {UpdateItem} updateItem Item object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItem(categoryId: string, itemId: string, updateItem: UpdateItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItem(categoryId, itemId, updateItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.patchItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new item
         * @param {string} categoryId ID of the category
         * @param {NewItem} newItem Item object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postItem(categoryId: string, newItem: NewItem, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postItem(categoryId, newItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.postItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemsApi - factory interface
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * (admin) Get all incoherent items with filters and pagination
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {ItemState} [state] Filter by state
         * @param {string} [categoryId] Filter by category
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIncoherentItems(page?: number, limit?: number, state?: ItemState, categoryId?: string, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAllItems200Response> {
            return localVarFp.getAllIncoherentItems(page, limit, state, categoryId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * (admin) Get all items with filters and pagination
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {ItemState} [state] Filter by state
         * @param {string} [categoryId] Filter by category
         * @param {string} [name] Filter by name
         * @param {Fournisseur} [fournisseur] Filter by fournisseur
         * @param {string} [refBundle] Filter by reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItems(page?: number, limit?: number, state?: ItemState, categoryId?: string, name?: string, fournisseur?: Fournisseur, refBundle?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAllItems200Response> {
            return localVarFp.getAllItems(page, limit, state, categoryId, name, fournisseur, refBundle, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all items of a category
         * @param {string} categoryId ID of the category
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {ItemState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryItems(categoryId: string, page?: number, limit?: number, state?: ItemState, options?: RawAxiosRequestConfig): AxiosPromise<GetAllItems200Response> {
            return localVarFp.getCategoryItems(categoryId, page, limit, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an item
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<Item> {
            return localVarFp.getItem(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an item picture
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemPicture(categoryId: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getItemPicture(categoryId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an item
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteItem(categoryId: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.markDeleteItem(categoryId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an item
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {UpdateItem} updateItem Item object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItem(categoryId: string, itemId: string, updateItem: UpdateItem, options?: RawAxiosRequestConfig): AxiosPromise<Item> {
            return localVarFp.patchItem(categoryId, itemId, updateItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new item
         * @param {string} categoryId ID of the category
         * @param {NewItem} newItem Item object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItem(categoryId: string, newItem: NewItem, options?: RawAxiosRequestConfig): AxiosPromise<Item> {
            return localVarFp.postItem(categoryId, newItem, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 */
export class ItemsApi extends BaseAPI {
    /**
     * (admin) Get all incoherent items with filters and pagination
     * @param {number} [page] Page number
     * @param {number} [limit] Number of items per page
     * @param {ItemState} [state] Filter by state
     * @param {string} [categoryId] Filter by category
     * @param {string} [name] Filter by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllIncoherentItems(page?: number, limit?: number, state?: ItemState, categoryId?: string, name?: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getAllIncoherentItems(page, limit, state, categoryId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (admin) Get all items with filters and pagination
     * @param {number} [page] Page number
     * @param {number} [limit] Number of items per page
     * @param {ItemState} [state] Filter by state
     * @param {string} [categoryId] Filter by category
     * @param {string} [name] Filter by name
     * @param {Fournisseur} [fournisseur] Filter by fournisseur
     * @param {string} [refBundle] Filter by reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllItems(page?: number, limit?: number, state?: ItemState, categoryId?: string, name?: string, fournisseur?: Fournisseur, refBundle?: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getAllItems(page, limit, state, categoryId, name, fournisseur, refBundle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all items of a category
     * @param {string} categoryId ID of the category
     * @param {number} [page] Page number
     * @param {number} [limit] Number of items per page
     * @param {ItemState} [state] Filter by state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCategoryItems(categoryId: string, page?: number, limit?: number, state?: ItemState, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getCategoryItems(categoryId, page, limit, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an item
     * @param {string} itemId ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getItem(itemId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItem(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an item picture
     * @param {string} categoryId ID of the category
     * @param {string} itemId ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getItemPicture(categoryId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItemPicture(categoryId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an item
     * @param {string} categoryId ID of the category
     * @param {string} itemId ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markDeleteItem(categoryId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).markDeleteItem(categoryId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an item
     * @param {string} categoryId ID of the category
     * @param {string} itemId ID of the item
     * @param {UpdateItem} updateItem Item object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchItem(categoryId: string, itemId: string, updateItem: UpdateItem, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).patchItem(categoryId, itemId, updateItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new item
     * @param {string} categoryId ID of the category
     * @param {NewItem} newItem Item object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postItem(categoryId: string, newItem: NewItem, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).postItem(categoryId, newItem, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RefillsApi - axios parameter creator
 */
export const RefillsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all refills of an account
         * @param {string} accountId ID or CardID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRefills: async (accountId: string, page?: number, limit?: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountRefills', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/refills`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all pending remote refills for your account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingRemoteRefills: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/remote-refills/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefills: async (page?: number, limit?: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/refills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of the remote refill system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteRefillStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/remote-refills/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all remote refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {RemoteRefillState} [state] State of the refill
         * @param {string} [accountName] Filter by account name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteRefills: async (page?: number, limit?: number, startDate?: string, endDate?: string, state?: RemoteRefillState, accountName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/remote-refills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (accountName !== undefined) {
                localVarQueryParameter['account_name'] = accountName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfRefills: async (page?: number, limit?: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/refills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a refill
         * @param {string} accountId ID of the account
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteRefill: async (accountId: string, refillId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('markDeleteRefill', 'accountId', accountId)
            // verify required parameter 'refillId' is not null or undefined
            assertParamExists('markDeleteRefill', 'refillId', refillId)
            const localVarPath = `/accounts/{account_id}/refills/{refill_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"refill_id"}}`, encodeURIComponent(String(refillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update refill\'s state
         * @param {string} accountId ID of the account
         * @param {string} refillId ID of the refill
         * @param {RefillState} [state] New state of the refill
         * @param {RefillType} [type] New type of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRefillId: async (accountId: string, refillId: string, state?: RefillState, type?: RefillType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('patchRefillId', 'accountId', accountId)
            // verify required parameter 'refillId' is not null or undefined
            assertParamExists('patchRefillId', 'refillId', refillId)
            const localVarPath = `/accounts/{account_id}/refills/{refill_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"refill_id"}}`, encodeURIComponent(String(refillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new refill
         * @param {string} accountId ID or CardID of the account
         * @param {number} amount Amount of the refill
         * @param {RefillType} type Type of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRefill: async (accountId: string, amount: number, type: RefillType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('postRefill', 'accountId', accountId)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('postRefill', 'amount', amount)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('postRefill', 'type', type)
            const localVarPath = `/accounts/{account_id}/refills`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a remote refill
         * @param {number} checkoutIntentId HelloAsso checkout intent id to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selfValidateRemoteRefill: async (checkoutIntentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutIntentId' is not null or undefined
            assertParamExists('selfValidateRemoteRefill', 'checkoutIntentId', checkoutIntentId)
            const localVarPath = `/account/remote-refills/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required

            if (checkoutIntentId !== undefined) {
                localVarQueryParameter['checkout_intent_id'] = checkoutIntentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a remote refill
         * @param {number} amount Amount of the refill in cents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRemoteRefill: async (amount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('startRemoteRefill', 'amount', amount)
            const localVarPath = `/account/remote-refills/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify a remote refill
         * @param {string} id Remote Refill id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyRemoteRefill: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('verifyRemoteRefill', 'id', id)
            const localVarPath = `/remote-refills/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefillsApi - functional programming interface
 */
export const RefillsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RefillsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all refills of an account
         * @param {string} accountId ID or CardID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountRefills(accountId: string, page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRefills200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountRefills(accountId, page, limit, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillsApi.getAccountRefills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all pending remote refills for your account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingRemoteRefills(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPendingRemoteRefills200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingRemoteRefills(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillsApi.getPendingRemoteRefills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRefills(page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRefills200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRefills(page, limit, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillsApi.getRefills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the status of the remote refill system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteRefillStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRemoteRefillStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillsApi.getRemoteRefillStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all remote refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {RemoteRefillState} [state] State of the refill
         * @param {string} [accountName] Filter by account name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteRefills(page?: number, limit?: number, startDate?: string, endDate?: string, state?: RemoteRefillState, accountName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRemoteRefills200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRemoteRefills(page, limit, startDate, endDate, state, accountName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillsApi.getRemoteRefills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSelfRefills(page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRefills200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSelfRefills(page, limit, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillsApi.getSelfRefills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancels a refill
         * @param {string} accountId ID of the account
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteRefill(accountId: string, refillId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteRefill(accountId, refillId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillsApi.markDeleteRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update refill\'s state
         * @param {string} accountId ID of the account
         * @param {string} refillId ID of the refill
         * @param {RefillState} [state] New state of the refill
         * @param {RefillType} [type] New type of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRefillId(accountId: string, refillId: string, state?: RefillState, type?: RefillType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRefillId(accountId, refillId, state, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillsApi.patchRefillId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new refill
         * @param {string} accountId ID or CardID of the account
         * @param {number} amount Amount of the refill
         * @param {RefillType} type Type of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRefill(accountId: string, amount: number, type: RefillType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRefill(accountId, amount, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillsApi.postRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate a remote refill
         * @param {number} checkoutIntentId HelloAsso checkout intent id to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async selfValidateRemoteRefill(checkoutIntentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.selfValidateRemoteRefill(checkoutIntentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillsApi.selfValidateRemoteRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a remote refill
         * @param {number} amount Amount of the refill in cents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRemoteRefill(amount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartRemoteRefill200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRemoteRefill(amount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillsApi.startRemoteRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify a remote refill
         * @param {string} id Remote Refill id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyRemoteRefill(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyRemoteRefill(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefillsApi.verifyRemoteRefill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RefillsApi - factory interface
 */
export const RefillsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RefillsApiFp(configuration)
    return {
        /**
         * Get all refills of an account
         * @param {string} accountId ID or CardID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRefills(accountId: string, page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRefills200Response> {
            return localVarFp.getAccountRefills(accountId, page, limit, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all pending remote refills for your account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingRemoteRefills(options?: RawAxiosRequestConfig): AxiosPromise<GetPendingRemoteRefills200Response> {
            return localVarFp.getPendingRemoteRefills(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefills(page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRefills200Response> {
            return localVarFp.getRefills(page, limit, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of the remote refill system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteRefillStatus(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getRemoteRefillStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all remote refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {RemoteRefillState} [state] State of the refill
         * @param {string} [accountName] Filter by account name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteRefills(page?: number, limit?: number, startDate?: string, endDate?: string, state?: RemoteRefillState, accountName?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRemoteRefills200Response> {
            return localVarFp.getRemoteRefills(page, limit, startDate, endDate, state, accountName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfRefills(page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRefills200Response> {
            return localVarFp.getSelfRefills(page, limit, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a refill
         * @param {string} accountId ID of the account
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteRefill(accountId: string, refillId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.markDeleteRefill(accountId, refillId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update refill\'s state
         * @param {string} accountId ID of the account
         * @param {string} refillId ID of the refill
         * @param {RefillState} [state] New state of the refill
         * @param {RefillType} [type] New type of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRefillId(accountId: string, refillId: string, state?: RefillState, type?: RefillType, options?: RawAxiosRequestConfig): AxiosPromise<Refill> {
            return localVarFp.patchRefillId(accountId, refillId, state, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new refill
         * @param {string} accountId ID or CardID of the account
         * @param {number} amount Amount of the refill
         * @param {RefillType} type Type of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRefill(accountId: string, amount: number, type: RefillType, options?: RawAxiosRequestConfig): AxiosPromise<Refill> {
            return localVarFp.postRefill(accountId, amount, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate a remote refill
         * @param {number} checkoutIntentId HelloAsso checkout intent id to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selfValidateRemoteRefill(checkoutIntentId: number, options?: RawAxiosRequestConfig): AxiosPromise<Refill> {
            return localVarFp.selfValidateRemoteRefill(checkoutIntentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a remote refill
         * @param {number} amount Amount of the refill in cents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRemoteRefill(amount: number, options?: RawAxiosRequestConfig): AxiosPromise<StartRemoteRefill200Response> {
            return localVarFp.startRemoteRefill(amount, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify a remote refill
         * @param {string} id Remote Refill id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyRemoteRefill(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Refill> {
            return localVarFp.verifyRemoteRefill(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RefillsApi - object-oriented interface
 */
export class RefillsApi extends BaseAPI {
    /**
     * Get all refills of an account
     * @param {string} accountId ID or CardID of the account
     * @param {number} [page] Page number
     * @param {number} [limit] Number of transactions per page
     * @param {string} [startDate] Start date of the refill
     * @param {string} [endDate] End date of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountRefills(accountId: string, page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return RefillsApiFp(this.configuration).getAccountRefills(accountId, page, limit, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all pending remote refills for your account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPendingRemoteRefills(options?: RawAxiosRequestConfig) {
        return RefillsApiFp(this.configuration).getPendingRemoteRefills(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all refills
     * @param {number} [page] Page number
     * @param {number} [limit] Number of transactions per page
     * @param {string} [startDate] Start date of the refill
     * @param {string} [endDate] End date of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRefills(page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return RefillsApiFp(this.configuration).getRefills(page, limit, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of the remote refill system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRemoteRefillStatus(options?: RawAxiosRequestConfig) {
        return RefillsApiFp(this.configuration).getRemoteRefillStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all remote refills
     * @param {number} [page] Page number
     * @param {number} [limit] Number of transactions per page
     * @param {string} [startDate] Start date of the refill
     * @param {string} [endDate] End date of the refill
     * @param {RemoteRefillState} [state] State of the refill
     * @param {string} [accountName] Filter by account name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRemoteRefills(page?: number, limit?: number, startDate?: string, endDate?: string, state?: RemoteRefillState, accountName?: string, options?: RawAxiosRequestConfig) {
        return RefillsApiFp(this.configuration).getRemoteRefills(page, limit, startDate, endDate, state, accountName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all refills
     * @param {number} [page] Page number
     * @param {number} [limit] Number of transactions per page
     * @param {string} [startDate] Start date of the refill
     * @param {string} [endDate] End date of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSelfRefills(page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return RefillsApiFp(this.configuration).getSelfRefills(page, limit, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a refill
     * @param {string} accountId ID of the account
     * @param {string} refillId ID of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markDeleteRefill(accountId: string, refillId: string, options?: RawAxiosRequestConfig) {
        return RefillsApiFp(this.configuration).markDeleteRefill(accountId, refillId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update refill\'s state
     * @param {string} accountId ID of the account
     * @param {string} refillId ID of the refill
     * @param {RefillState} [state] New state of the refill
     * @param {RefillType} [type] New type of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchRefillId(accountId: string, refillId: string, state?: RefillState, type?: RefillType, options?: RawAxiosRequestConfig) {
        return RefillsApiFp(this.configuration).patchRefillId(accountId, refillId, state, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new refill
     * @param {string} accountId ID or CardID of the account
     * @param {number} amount Amount of the refill
     * @param {RefillType} type Type of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postRefill(accountId: string, amount: number, type: RefillType, options?: RawAxiosRequestConfig) {
        return RefillsApiFp(this.configuration).postRefill(accountId, amount, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate a remote refill
     * @param {number} checkoutIntentId HelloAsso checkout intent id to validate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public selfValidateRemoteRefill(checkoutIntentId: number, options?: RawAxiosRequestConfig) {
        return RefillsApiFp(this.configuration).selfValidateRemoteRefill(checkoutIntentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a remote refill
     * @param {number} amount Amount of the refill in cents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public startRemoteRefill(amount: number, options?: RawAxiosRequestConfig) {
        return RefillsApiFp(this.configuration).startRemoteRefill(amount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify a remote refill
     * @param {string} id Remote Refill id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verifyRemoteRefill(id: string, options?: RawAxiosRequestConfig) {
        return RefillsApiFp(this.configuration).verifyRemoteRefill(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RestocksApi - axios parameter creator
 */
export const RestocksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a restock
         * @param {NewRestock} newRestock Restock to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRestock: async (newRestock: NewRestock, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newRestock' is not null or undefined
            assertParamExists('createRestock', 'newRestock', newRestock)
            const localVarPath = `/restocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newRestock, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a restock
         * @param {string} restockId ID of the restock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRestock: async (restockId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'restockId' is not null or undefined
            assertParamExists('deleteRestock', 'restockId', restockId)
            const localVarPath = `/restocks/{restock_id}`
                .replace(`{${"restock_id"}}`, encodeURIComponent(String(restockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get restocks
         * @param {number} [page] Page number
         * @param {number} [limit] Number of restocks per page
         * @param {RestockState} [state] search state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestocks: async (page?: number, limit?: number, state?: RestockState, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/restocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a restock
         * @param {string} restockId ID of the restock
         * @param {NewRestock} newRestock Restock to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRestock: async (restockId: string, newRestock: NewRestock, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'restockId' is not null or undefined
            assertParamExists('updateRestock', 'restockId', restockId)
            // verify required parameter 'newRestock' is not null or undefined
            assertParamExists('updateRestock', 'newRestock', newRestock)
            const localVarPath = `/restocks/{restock_id}`
                .replace(`{${"restock_id"}}`, encodeURIComponent(String(restockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newRestock, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestocksApi - functional programming interface
 */
export const RestocksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RestocksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a restock
         * @param {NewRestock} newRestock Restock to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRestock(newRestock: NewRestock, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Restock>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRestock(newRestock, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestocksApi.createRestock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a restock
         * @param {string} restockId ID of the restock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRestock(restockId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRestock(restockId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestocksApi.deleteRestock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get restocks
         * @param {number} [page] Page number
         * @param {number} [limit] Number of restocks per page
         * @param {RestockState} [state] search state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRestocks(page?: number, limit?: number, state?: RestockState, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRestocks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRestocks(page, limit, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestocksApi.getRestocks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a restock
         * @param {string} restockId ID of the restock
         * @param {NewRestock} newRestock Restock to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRestock(restockId: string, newRestock: NewRestock, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRestock(restockId, newRestock, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RestocksApi.updateRestock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RestocksApi - factory interface
 */
export const RestocksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RestocksApiFp(configuration)
    return {
        /**
         * Create a restock
         * @param {NewRestock} newRestock Restock to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRestock(newRestock: NewRestock, options?: RawAxiosRequestConfig): AxiosPromise<Restock> {
            return localVarFp.createRestock(newRestock, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a restock
         * @param {string} restockId ID of the restock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRestock(restockId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRestock(restockId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get restocks
         * @param {number} [page] Page number
         * @param {number} [limit] Number of restocks per page
         * @param {RestockState} [state] search state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestocks(page?: number, limit?: number, state?: RestockState, options?: RawAxiosRequestConfig): AxiosPromise<GetRestocks200Response> {
            return localVarFp.getRestocks(page, limit, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a restock
         * @param {string} restockId ID of the restock
         * @param {NewRestock} newRestock Restock to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRestock(restockId: string, newRestock: NewRestock, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateRestock(restockId, newRestock, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RestocksApi - object-oriented interface
 */
export class RestocksApi extends BaseAPI {
    /**
     * Create a restock
     * @param {NewRestock} newRestock Restock to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRestock(newRestock: NewRestock, options?: RawAxiosRequestConfig) {
        return RestocksApiFp(this.configuration).createRestock(newRestock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a restock
     * @param {string} restockId ID of the restock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRestock(restockId: string, options?: RawAxiosRequestConfig) {
        return RestocksApiFp(this.configuration).deleteRestock(restockId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get restocks
     * @param {number} [page] Page number
     * @param {number} [limit] Number of restocks per page
     * @param {RestockState} [state] search state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRestocks(page?: number, limit?: number, state?: RestockState, options?: RawAxiosRequestConfig) {
        return RestocksApiFp(this.configuration).getRestocks(page, limit, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a restock
     * @param {string} restockId ID of the restock
     * @param {NewRestock} newRestock Restock to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRestock(restockId: string, newRestock: NewRestock, options?: RawAxiosRequestConfig) {
        return RestocksApiFp(this.configuration).updateRestock(restockId, newRestock, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StarsApi - axios parameter creator
 */
export const StarsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all stars donations of an account
         * @param {string} accountId ID or CardID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of donations per page
         * @param {string} [startDate] Start date of the donation
         * @param {string} [endDate] End date of the donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountStarring: async (accountId: string, page?: number, limit?: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountStarring', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/stars`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all stars donations
         * @param {number} [page] Page number
         * @param {number} [limit] Number of donations per page
         * @param {string} [startDate] Start date of the donation
         * @param {string} [endDate] End date of the donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfStarring: async (page?: number, limit?: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/stars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all stars donations
         * @param {number} [page] Page number
         * @param {number} [limit] Number of donations per page
         * @param {string} [name] Filter by account name
         * @param {string} [startDate] Start date of the donations
         * @param {string} [endDate] End date of the donations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarrings: async (page?: number, limit?: number, name?: string, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a donation
         * @param {string} accountId ID of the account
         * @param {string} starringId ID of the donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteStarring: async (accountId: string, starringId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('markDeleteStarring', 'accountId', accountId)
            // verify required parameter 'starringId' is not null or undefined
            assertParamExists('markDeleteStarring', 'starringId', starringId)
            const localVarPath = `/accounts/{account_id}/stars/{starring_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"starring_id"}}`, encodeURIComponent(String(starringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update donation\'s state
         * @param {string} accountId ID of the account
         * @param {string} starringId ID of the donation
         * @param {StarringState} [state] New state of the donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStarringId: async (accountId: string, starringId: string, state?: StarringState, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('patchStarringId', 'accountId', accountId)
            // verify required parameter 'starringId' is not null or undefined
            assertParamExists('patchStarringId', 'starringId', starringId)
            const localVarPath = `/accounts/{account_id}/stars/{starring_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"starring_id"}}`, encodeURIComponent(String(starringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new stars donations
         * @param {string} accountId ID or CardID of the account
         * @param {number} amount Amount of the starring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStarring: async (accountId: string, amount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('postStarring', 'accountId', accountId)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('postStarring', 'amount', amount)
            const localVarPath = `/accounts/{account_id}/stars`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StarsApi - functional programming interface
 */
export const StarsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StarsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all stars donations of an account
         * @param {string} accountId ID or CardID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of donations per page
         * @param {string} [startDate] Start date of the donation
         * @param {string} [endDate] End date of the donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountStarring(accountId: string, page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStarrings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountStarring(accountId, page, limit, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StarsApi.getAccountStarring']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all stars donations
         * @param {number} [page] Page number
         * @param {number} [limit] Number of donations per page
         * @param {string} [startDate] Start date of the donation
         * @param {string} [endDate] End date of the donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSelfStarring(page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStarrings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSelfStarring(page, limit, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StarsApi.getSelfStarring']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all stars donations
         * @param {number} [page] Page number
         * @param {number} [limit] Number of donations per page
         * @param {string} [name] Filter by account name
         * @param {string} [startDate] Start date of the donations
         * @param {string} [endDate] End date of the donations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStarrings(page?: number, limit?: number, name?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStarrings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStarrings(page, limit, name, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StarsApi.getStarrings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancels a donation
         * @param {string} accountId ID of the account
         * @param {string} starringId ID of the donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteStarring(accountId: string, starringId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteStarring(accountId, starringId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StarsApi.markDeleteStarring']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update donation\'s state
         * @param {string} accountId ID of the account
         * @param {string} starringId ID of the donation
         * @param {StarringState} [state] New state of the donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStarringId(accountId: string, starringId: string, state?: StarringState, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Starring>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchStarringId(accountId, starringId, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StarsApi.patchStarringId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new stars donations
         * @param {string} accountId ID or CardID of the account
         * @param {number} amount Amount of the starring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStarring(accountId: string, amount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Starring>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postStarring(accountId, amount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StarsApi.postStarring']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StarsApi - factory interface
 */
export const StarsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StarsApiFp(configuration)
    return {
        /**
         * Get all stars donations of an account
         * @param {string} accountId ID or CardID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of donations per page
         * @param {string} [startDate] Start date of the donation
         * @param {string} [endDate] End date of the donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountStarring(accountId: string, page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetStarrings200Response> {
            return localVarFp.getAccountStarring(accountId, page, limit, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all stars donations
         * @param {number} [page] Page number
         * @param {number} [limit] Number of donations per page
         * @param {string} [startDate] Start date of the donation
         * @param {string} [endDate] End date of the donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfStarring(page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetStarrings200Response> {
            return localVarFp.getSelfStarring(page, limit, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all stars donations
         * @param {number} [page] Page number
         * @param {number} [limit] Number of donations per page
         * @param {string} [name] Filter by account name
         * @param {string} [startDate] Start date of the donations
         * @param {string} [endDate] End date of the donations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarrings(page?: number, limit?: number, name?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetStarrings200Response> {
            return localVarFp.getStarrings(page, limit, name, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a donation
         * @param {string} accountId ID of the account
         * @param {string} starringId ID of the donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteStarring(accountId: string, starringId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.markDeleteStarring(accountId, starringId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update donation\'s state
         * @param {string} accountId ID of the account
         * @param {string} starringId ID of the donation
         * @param {StarringState} [state] New state of the donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStarringId(accountId: string, starringId: string, state?: StarringState, options?: RawAxiosRequestConfig): AxiosPromise<Starring> {
            return localVarFp.patchStarringId(accountId, starringId, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new stars donations
         * @param {string} accountId ID or CardID of the account
         * @param {number} amount Amount of the starring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStarring(accountId: string, amount: number, options?: RawAxiosRequestConfig): AxiosPromise<Starring> {
            return localVarFp.postStarring(accountId, amount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StarsApi - object-oriented interface
 */
export class StarsApi extends BaseAPI {
    /**
     * Get all stars donations of an account
     * @param {string} accountId ID or CardID of the account
     * @param {number} [page] Page number
     * @param {number} [limit] Number of donations per page
     * @param {string} [startDate] Start date of the donation
     * @param {string} [endDate] End date of the donation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountStarring(accountId: string, page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return StarsApiFp(this.configuration).getAccountStarring(accountId, page, limit, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all stars donations
     * @param {number} [page] Page number
     * @param {number} [limit] Number of donations per page
     * @param {string} [startDate] Start date of the donation
     * @param {string} [endDate] End date of the donation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSelfStarring(page?: number, limit?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return StarsApiFp(this.configuration).getSelfStarring(page, limit, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all stars donations
     * @param {number} [page] Page number
     * @param {number} [limit] Number of donations per page
     * @param {string} [name] Filter by account name
     * @param {string} [startDate] Start date of the donations
     * @param {string} [endDate] End date of the donations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStarrings(page?: number, limit?: number, name?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return StarsApiFp(this.configuration).getStarrings(page, limit, name, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a donation
     * @param {string} accountId ID of the account
     * @param {string} starringId ID of the donation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markDeleteStarring(accountId: string, starringId: string, options?: RawAxiosRequestConfig) {
        return StarsApiFp(this.configuration).markDeleteStarring(accountId, starringId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update donation\'s state
     * @param {string} accountId ID of the account
     * @param {string} starringId ID of the donation
     * @param {StarringState} [state] New state of the donation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchStarringId(accountId: string, starringId: string, state?: StarringState, options?: RawAxiosRequestConfig) {
        return StarsApiFp(this.configuration).patchStarringId(accountId, starringId, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new stars donations
     * @param {string} accountId ID or CardID of the account
     * @param {number} amount Amount of the starring
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postStarring(accountId: string, amount: number, options?: RawAxiosRequestConfig) {
        return StarsApiFp(this.configuration).postStarring(accountId, amount, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionsApi - axios parameter creator
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all transactions
         * @summary 
         * @param {string} accountId ID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactions: async (accountId: string, page?: number, limit?: number, state?: TransactionState, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountTransactions', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/transactions`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all transactions
         * @summary 
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentAccountTransactions: async (page?: number, limit?: number, state?: TransactionState, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get transaction
         * @summary 
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionId: async (accountId: string, transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getTransactionId', 'accountId', accountId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getTransactionId', 'transactionId', transactionId)
            const localVarPath = `/accounts/{account_id}/transactions/{transaction_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all active transactions (orders)
         * @summary 
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [transactionState] Filter transaction by state
         * @param {boolean} [hideCanceled] Hide canceled items
         * @param {boolean} [hideRemote] Hide remote transactions
         * @param {string} [name] Filter by account name
         * @param {number} [startTime] Filter by start_time
         * @param {number} [endTime] Filter by end_time
         * @param {string} [itemId] Filter by item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (page?: number, limit?: number, transactionState?: TransactionState, hideCanceled?: boolean, hideRemote?: boolean, name?: string, startTime?: number, endTime?: number, itemId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (transactionState !== undefined) {
                localVarQueryParameter['transaction_state'] = transactionState;
            }

            if (hideCanceled !== undefined) {
                localVarQueryParameter['hide_canceled'] = hideCanceled;
            }

            if (hideRemote !== undefined) {
                localVarQueryParameter['hide_remote'] = hideRemote;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all items in active transactions (ordered items)
         * @summary 
         * @param {string} [name] Filter by item name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsItems: async (name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete transaction
         * @summary 
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteTransactionId: async (accountId: string, transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('markDeleteTransactionId', 'accountId', accountId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('markDeleteTransactionId', 'transactionId', transactionId)
            const localVarPath = `/accounts/{account_id}/transactions/{transaction_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update transaction\'s state
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {TransactionState} state New state of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTransactionId: async (accountId: string, transactionId: string, state: TransactionState, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('patchTransactionId', 'accountId', accountId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('patchTransactionId', 'transactionId', transactionId)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('patchTransactionId', 'state', state)
            const localVarPath = `/accounts/{account_id}/transactions/{transaction_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update transaction\'s item state
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {string} itemId ID of the item
         * @param {TransactionItemState} [state] New state of the item
         * @param {number} [amount] New amount of the item
         * @param {number} [alreadyDone] Update item\&#39;s already done
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTransactionItemId: async (accountId: string, transactionId: string, itemId: string, state?: TransactionItemState, amount?: number, alreadyDone?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('patchTransactionItemId', 'accountId', accountId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('patchTransactionItemId', 'transactionId', transactionId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('patchTransactionItemId', 'itemId', itemId)
            const localVarPath = `/accounts/{account_id}/transactions/{transaction_id}/{item_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (alreadyDone !== undefined) {
                localVarQueryParameter['already_done'] = alreadyDone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new transaction
         * @summary 
         * @param {NewTransaction} [newTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransactions: async (newTransaction?: NewTransaction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newTransaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all transactions
         * @summary 
         * @param {string} accountId ID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTransactions(accountId: string, page?: number, limit?: number, state?: TransactionState, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountTransactions(accountId, page, limit, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.getAccountTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all transactions
         * @summary 
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentAccountTransactions(page?: number, limit?: number, state?: TransactionState, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentAccountTransactions(page, limit, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.getCurrentAccountTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get transaction
         * @summary 
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionId(accountId: string, transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionId(accountId, transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.getTransactionId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all active transactions (orders)
         * @summary 
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [transactionState] Filter transaction by state
         * @param {boolean} [hideCanceled] Hide canceled items
         * @param {boolean} [hideRemote] Hide remote transactions
         * @param {string} [name] Filter by account name
         * @param {number} [startTime] Filter by start_time
         * @param {number} [endTime] Filter by end_time
         * @param {string} [itemId] Filter by item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(page?: number, limit?: number, transactionState?: TransactionState, hideCanceled?: boolean, hideRemote?: boolean, name?: string, startTime?: number, endTime?: number, itemId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(page, limit, transactionState, hideCanceled, hideRemote, name, startTime, endTime, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.getTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all items in active transactions (ordered items)
         * @summary 
         * @param {string} [name] Filter by item name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsItems(name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsItems(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.getTransactionsItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete transaction
         * @summary 
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteTransactionId(accountId: string, transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTTPError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteTransactionId(accountId, transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.markDeleteTransactionId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update transaction\'s state
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {TransactionState} state New state of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTransactionId(accountId: string, transactionId: string, state: TransactionState, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTTPError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTransactionId(accountId, transactionId, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.patchTransactionId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update transaction\'s item state
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {string} itemId ID of the item
         * @param {TransactionItemState} [state] New state of the item
         * @param {number} [amount] New amount of the item
         * @param {number} [alreadyDone] Update item\&#39;s already done
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTransactionItemId(accountId: string, transactionId: string, itemId: string, state?: TransactionItemState, amount?: number, alreadyDone?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTTPError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTransactionItemId(accountId, transactionId, itemId, state, amount, alreadyDone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.patchTransactionItemId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new transaction
         * @summary 
         * @param {NewTransaction} [newTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTransactions(newTransaction?: NewTransaction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTransactions(newTransaction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.postTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionsApi - factory interface
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Get all transactions
         * @summary 
         * @param {string} accountId ID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactions(accountId: string, page?: number, limit?: number, state?: TransactionState, options?: RawAxiosRequestConfig): AxiosPromise<GetTransactions200Response> {
            return localVarFp.getAccountTransactions(accountId, page, limit, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all transactions
         * @summary 
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentAccountTransactions(page?: number, limit?: number, state?: TransactionState, options?: RawAxiosRequestConfig): AxiosPromise<GetTransactions200Response> {
            return localVarFp.getCurrentAccountTransactions(page, limit, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Get transaction
         * @summary 
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionId(accountId: string, transactionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Transaction> {
            return localVarFp.getTransactionId(accountId, transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all active transactions (orders)
         * @summary 
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [transactionState] Filter transaction by state
         * @param {boolean} [hideCanceled] Hide canceled items
         * @param {boolean} [hideRemote] Hide remote transactions
         * @param {string} [name] Filter by account name
         * @param {number} [startTime] Filter by start_time
         * @param {number} [endTime] Filter by end_time
         * @param {string} [itemId] Filter by item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(page?: number, limit?: number, transactionState?: TransactionState, hideCanceled?: boolean, hideRemote?: boolean, name?: string, startTime?: number, endTime?: number, itemId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetTransactions200Response> {
            return localVarFp.getTransactions(page, limit, transactionState, hideCanceled, hideRemote, name, startTime, endTime, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all items in active transactions (ordered items)
         * @summary 
         * @param {string} [name] Filter by item name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsItems(name?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TransactionItem>> {
            return localVarFp.getTransactionsItems(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete transaction
         * @summary 
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteTransactionId(accountId: string, transactionId: string, options?: RawAxiosRequestConfig): AxiosPromise<HTTPError> {
            return localVarFp.markDeleteTransactionId(accountId, transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update transaction\'s state
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {TransactionState} state New state of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTransactionId(accountId: string, transactionId: string, state: TransactionState, options?: RawAxiosRequestConfig): AxiosPromise<HTTPError> {
            return localVarFp.patchTransactionId(accountId, transactionId, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Update transaction\'s item state
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {string} itemId ID of the item
         * @param {TransactionItemState} [state] New state of the item
         * @param {number} [amount] New amount of the item
         * @param {number} [alreadyDone] Update item\&#39;s already done
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTransactionItemId(accountId: string, transactionId: string, itemId: string, state?: TransactionItemState, amount?: number, alreadyDone?: number, options?: RawAxiosRequestConfig): AxiosPromise<HTTPError> {
            return localVarFp.patchTransactionItemId(accountId, transactionId, itemId, state, amount, alreadyDone, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new transaction
         * @summary 
         * @param {NewTransaction} [newTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransactions(newTransaction?: NewTransaction, options?: RawAxiosRequestConfig): AxiosPromise<Transaction> {
            return localVarFp.postTransactions(newTransaction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Get all transactions
     * @summary 
     * @param {string} accountId ID of the account
     * @param {number} [page] Page number
     * @param {number} [limit] Number of transactions per page
     * @param {TransactionState} [state] Filter by state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountTransactions(accountId: string, page?: number, limit?: number, state?: TransactionState, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getAccountTransactions(accountId, page, limit, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all transactions
     * @summary 
     * @param {number} [page] Page number
     * @param {number} [limit] Number of transactions per page
     * @param {TransactionState} [state] Filter by state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCurrentAccountTransactions(page?: number, limit?: number, state?: TransactionState, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getCurrentAccountTransactions(page, limit, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get transaction
     * @summary 
     * @param {string} accountId ID of the account
     * @param {string} transactionId ID of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTransactionId(accountId: string, transactionId: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionId(accountId, transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all active transactions (orders)
     * @summary 
     * @param {number} [page] Page number
     * @param {number} [limit] Number of transactions per page
     * @param {TransactionState} [transactionState] Filter transaction by state
     * @param {boolean} [hideCanceled] Hide canceled items
     * @param {boolean} [hideRemote] Hide remote transactions
     * @param {string} [name] Filter by account name
     * @param {number} [startTime] Filter by start_time
     * @param {number} [endTime] Filter by end_time
     * @param {string} [itemId] Filter by item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTransactions(page?: number, limit?: number, transactionState?: TransactionState, hideCanceled?: boolean, hideRemote?: boolean, name?: string, startTime?: number, endTime?: number, itemId?: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactions(page, limit, transactionState, hideCanceled, hideRemote, name, startTime, endTime, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all items in active transactions (ordered items)
     * @summary 
     * @param {string} [name] Filter by item name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTransactionsItems(name?: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionsItems(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete transaction
     * @summary 
     * @param {string} accountId ID of the account
     * @param {string} transactionId ID of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public markDeleteTransactionId(accountId: string, transactionId: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).markDeleteTransactionId(accountId, transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update transaction\'s state
     * @param {string} accountId ID of the account
     * @param {string} transactionId ID of the transaction
     * @param {TransactionState} state New state of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchTransactionId(accountId: string, transactionId: string, state: TransactionState, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).patchTransactionId(accountId, transactionId, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update transaction\'s item state
     * @param {string} accountId ID of the account
     * @param {string} transactionId ID of the transaction
     * @param {string} itemId ID of the item
     * @param {TransactionItemState} [state] New state of the item
     * @param {number} [amount] New amount of the item
     * @param {number} [alreadyDone] Update item\&#39;s already done
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public patchTransactionItemId(accountId: string, transactionId: string, itemId: string, state?: TransactionItemState, amount?: number, alreadyDone?: number, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).patchTransactionItemId(accountId, transactionId, itemId, state, amount, alreadyDone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new transaction
     * @summary 
     * @param {NewTransaction} [newTransaction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTransactions(newTransaction?: NewTransaction, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).postTransactions(newTransaction, options).then((request) => request(this.axios, this.basePath));
    }
}



